---
title: "Pivoting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pivoting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette describes the use of the new `pivot_long()` and `pivot_wide()` functions. These are complete reimaginings of `gather()` and `spread()` that aim to solve:

* The challenge of remembering which direction is spreading and which is
  gathering.
  
* The supoptimal argument names which mean that you need to consistently
  refresh your memory by reading the documentation.

They also differ from previous functions in tidyr, reshape2, and reshape, in two more profound ways:

* The reshaping operation is specified with a data frame that describes 
  precisely how metadata stored in column names becomes real data variables. 
  This is inspired by the [cdata](https://winvector.github.io/cdata/) package 
  by John Mount and Nina Zumel. For simple cases, this specification is
  implicit, but for more complex cases it is useful to make it explicit.
  
* Reshaping works with multiple value variables that may have different types. 
  This is inspired by the enhanced `melt()` and `dcast()` functions provided 
  by the [data.table](https://github.com/Rdatatable/data.table/wiki) package
  by Matt Dowle and Arun Srinivasan.

The goal of this vignette is to get you up to speed with these new functions as quickly as possible.

```{r setup}
library(tidyr)
library(dplyr)
library(readr)
```

# Wide to long

`pivot_long()` makes datasets __longer__ by reducing the number of columns and increasing the number of rows. `pivot_long()` is commonly needed to tidy wild-caught datasets as they often optimse ease of data entry or comparison rather than ease of analysis. 

## Pew

The `pew` dataset is a 2d table with religion in the rows, income spread across the column names, and a count stored in the cell values:

```{r}
pew <- read_csv("pew.csv", col_types = list())
pew
```

To tidy this data we need `pivot_long()`:

```{r}
pew %>% 
  pivot_long(cols = -religion, names_to = "income", values_to = "count")
```

* The first argument describes which columns need to be transformed. 
  In this case, it's every column apart from the religion.

* The `names_to` gives the name of the variable that will be created from
  the data stored in the column names.
  
* The `values_to` gives the name of the variable that will be created from
  the data stored in the cell values.
  
Neither `names_to` nor the `values_to` column exists, so we have to put their name in quotes.

## Billboard

For many datasets, `pivot_long()` is all you need. But for more complex datasets it often makes sense to manully generate a data frame that precisely describes the transformation. For example, take the billboard data:

```{r}
billboard <- read_csv("billboard.csv", col_types = list(time = col_skip()))
billboard
```

This records the billboard rank of songs over time. It is very similar in form to the `pew` data above, but the data encoded in the column names is really a number, not a string. This means that `pivot_long()` works, but will require some additional cleaning afterwards.

```{r}
billboard %>% 
  pivot_long(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    na.rm = TRUE
  )
```

Instead of doing that cleaning on the long form of the data, we can tackle the problem in another way: by generating a pivot spec. A pivoting spec is a data frame that has one row for each column that needs to be transformed, describing the metadata that is encoded in this variable. (Using a pivotting spec is probably overkill for this problem, but it's a good bridge between very simple cases and the more complex cases you'll learn about shortly.)

We can start with the basic spec that `pivot_long()` generates behind the scenes:

```{r}
spec <- billboard %>% 
  pivot_long_spec(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
spec
```

The spec is a data frame with one row for each column, and two special columns that start with `.`:

* `.name` gives the name of the column
* `.value` gives the name of the column that the values in the cells will
  go into.

To make this spec a more accurate rendition of the metadata that's stored in the column names, we want to strip off the `"wk"` prefix and turn the string into a number. We can do that in one step with `readr::parse_number()`[^readr]:

[^readr]: It's not uncommon to use readr functions when generating pivoting specifications. This isn't too surprising as the job of the readr packge is to turn text into data.

```{r}
spec <- spec %>% 
  mutate(week = parse_number(week))
spec
```

We can now provide this spec to `pivot_long()`:

```{r}
billboard %>% 
  pivot_long(spec = spec)
```

Note we can now be more precise about the output shape of `pivot_long(df, spec = spec)`: it will have `nrow(df) * nrow(spec)` rows, and `ncol(df) - nrow(spec) + ncol(spec) - 2` columns.

## WHO tuberculosis data

In more complex cases, the column name might encode multiple variables, and require more significant parsing to extract. For example take the `who` dataset bundled with this package:

```{r}
who
```

```{r}
spec <- who %>%
  pivot_long_spec(new_sp_m014:newrel_f65, values_to = "count")
spec
```

The columns names (`new_sp_m014` through `newrel_f65)` encode four variables:

* The `new_`/`new` prefix indicates these are counts of new cases. This
  dataset only contains new cases, so we can ignore this component because 
  it's constant.
  
* `sp`/`rel`/`sp`/`ep` describe how the case was diagnosed.

* `m`/`f` indicate the gender of the person

* `014`/`1524`/`2535`/`3544`/`4554`/`65` indicate the age range.

We can extract these varables out of the `variable` variable using `extract()`:

```{r}
spec <- spec %>%
  extract(name, c("diagnosis", "gender", "age"), "new_?(.*)_(.)(.*)")
spec
```

Gender and age have fixed and known values, so it's good practice to convert these strings to factors:

```{r}
spec <- spec %>%
  mutate(
    gender = factor(gender, levels = c("f", "m")),
    age = factor(age, levels = unique(age), ordered = TRUE)
  )
spec
```

Finally, we can use this spec to tidy the dataset:

```{r}
who %>% pivot_long(spec = spec, na.rm = TRUE)
```

## Census data

Sometimes it's not possible to derive the spec from the data in the variables. In this case, it can be convenient to construct the spec completed by hand. For example, take this `construction` data, which is lightly modified from Table 5 "completions" found at 
<https://www.census.gov/construction/nrc/index.html>:

```{r}
construction <- read_csv("construction.csv", col_types = list("2 to 4 units" = col_integer()))
construction
```

This sort of data is not uncommon from government agencies: the column names actually belong to different variables, and here we have summaries for number of units (1, 2-4, 5+) and regions of the country (NE, NW, midW, S, W). We can most easily describe that will a tibble:

```{r}
spec <- tribble(
  ~.name,            ~.value, ~units,  ~region,     
  "Total",           "n",     "total", NA,          
  "1 unit",          "n",     "1",     NA,          
  "2 to 4 units",    "n",     "2-4",   NA,          
  "5 units or more", "n",     "5+",    NA,          
  "Northeast",       "n",     NA,      "Northeast", 
  "Midwest",         "n",     NA,      "Midwest",   
  "South",           "n",     NA,      "South",     
  "West",            "n",     NA,      "West",      
)
```

Which again we can use to tidy the data:

```{r}
construction %>% pivot_long(spec = spec)
```

## Multiple value columns 

So far the `.value` column has been constant, so you might wonder why we need it. An explicit specification can be used to access a new feature inspired by data.table: it's now possible gather columns with different types. The following example is adapted from the [data.table vignette](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html):

```{r}
family <- tibble::tribble(
  ~family_id,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,
          1L, "1998-11-26", "2000-01-29",             1L,             2L,
          2L, "1996-06-22",           NA,             2L,             NA,
          3L, "2002-07-11", "2004-04-05",             2L,             2L,
          4L, "2004-10-10", "2009-08-27",             1L,             1L,
          5L, "2000-12-05", "2005-02-28",             2L,             1L,
)
family <- family %>% mutate_at(vars(starts_with("dob")), parse_date)
family
```

Note that we have two pieces of information about each child: their gender and their date of birth. These need to go into separate columns in the result. We can do this by generating a spec where the `.value` column varies.

```{r}
spec <- family %>%
  pivot_long_spec(-family_id) %>%
  separate(name, c(".value", "child")) %>%
  mutate(child = parse_number(child))
spec
```

```{r}
family %>%
  pivot_long(spec = spec, na.rm = TRUE)
```

# Long to wide

`pivot_wide()` is the opposite of `pivot_long()`: it makes a dataset __wider__ by reducing the number of rows and increasing the number of columns. It's relatively rare to need `pivot_wide()` to make tidy data, but it's commonly needed to produce data compatible with other systems.

(Note that it is generally true that `pivot_long()` and `pivot_wide()` are precisely symmetric: `df %>% pivot_long(spec = spec) %>% pivot_wide(spec = spec)` and `df %>% pivot_wide(spec = spec) %>% pivot_long(spec = spec)` will yield `df`)

## Capture-recapture data

From <https://github.com/PlethodoNick/markrecapture>

```{r}
mr <- read_csv("mark-recapture.csv", col_types = list()) %>% 
  transmute(
    date = as.Date(strptime(Date, "%d-%b-%y")),
    individual = match(Individual, unique(Individual)),
    seen = 1
  ) %>% 
  filter(individual <= 10)
mr
```

Often need a form where each time-point is a column.

```{r}
mr %>% pivot_wide(date, seen)
```

```{r}
mr %>% pivot_wide(
  names_from = date, 
  values_from = seen, 
  names_prefix = "time_", 
  values_fill = list(seen = 0)
)
```

## Multiple `names_from`

Imagine, as in <http://stackoverflow.com/questions/24929954>, that we have information collected the combination of product, country, and year. In tidy form it might look like this:

```{r}
df <- expand_grid(
    product = c("A", "B"), 
    country = c("AI", "EI"), 
    year = 2000:2014
  ) %>%
  filter(
    (product == "A" & country == "AI") | 
    (product == "B" & country == "EI")
  ) %>% 
  mutate(value = rnorm(nrow(.)))
df
```

We want to widen the data so we have one column for each combination of `product` and `country`

```{r}
df %>% pivot_wide(names_from = c(product, country), values_from = value)
```

For this data set, you might want to generate a custom spec if you wanted to ensure that every possible combination of `country` and `product` got it's own column, not just those present in the data:

```{r}
spec <- df %>% 
  expand(product, country, .value = "value") %>% 
  unite(".name", product, country, remove = FALSE)
spec

df %>% pivot_wide(spec = spec) %>% head()
```

## Multiple measure

(From Jenny Bryan)

```{r}
input <- tribble(
  ~hw,   ~name,  ~mark,   ~pr,
  "hw1", "anna",    95,  "ok",
  "hw1", "alan",    90, "meh",
  "hw1", "carl",    85,  "ok",
  "hw2", "alan",    70, "meh",
  "hw2", "carl",    80,  "ok"
)

spec <- input %>% 
  expand(hw, .value = c("mark", "pr")) %>% 
  mutate(
    .name = paste0(hw, "_", .value)
  )
spec

input %>% pivot_wide(spec = spec)
```



# Multiple transformations

## Anscombe's quartet

Need to introduce identifying variable

```{r}
anscombe <- anscombe %>% 
  as_tibble() %>% 
  mutate(id = row_number())
anscombe

spec <- anscombe %>% 
  pivot_long_spec(-id) %>% 
  separate(name, c("var", "ex"), 1, convert = TRUE)
spec

anscombe %>% 
  pivot_long(spec = spec) %>% 
  pivot_wide(var, value)
```

## World bank

Need to `pivot_long` and then `pivot_wide`.

```{r, eval = FALSE}
# https://data.worldbank.org/topic/climate-change?view=chart
wb <- read_csv("vignettes/API_19_DS2_en_csv_v2_10400593.csv", skip = 4)
wb %>% select(country = `Country Code`, indicator = `Indicator Code`, `1960`:`2018`)
```


## Weather data

Need to `pivot_long` and then `pivot_wide`. Retire in favour of World Bank?

```{r}
weather <- read_csv("weather.csv", col_types = list()) 
weather
```

```{r}
weather %>% 
  pivot_long(d1:d31, names_to = "day", values_to = "temp", na.rm = TRUE) 
```

```{r}
weather %>% 
  pivot_long(d1:d31, names_to = "day", values_to = "temp", na.rm = TRUE) %>% 
  pivot_wide(names_from = element, values_from = temp)
```

## Contact list

Requires to widening twice.

Inspired by <https://github.com/jienagu/tidyverse_examples/blob/master/example_long_wide.R>

```{r}
contacts <- 
  c(
    "company", "Toyota", "name", "Jiena McLellan",
    "company", "McDonalds", "name", "John Smith"
  )

df <- tibble(meta = contacts)
df <- df %>% 
  mutate(
    id = cumsum(meta == "company"),
    row = rep(seq_len(nrow(df) / 2), each = 2),
    type = rep(c("var", "value"), length = nrow(df))
  ) 

spec <- pivot_wide_spec(df, names_from = type, values_from = meta)
df2 <- df %>% pivot_wide(spec = spec)

spec2 <- pivot_wide_spec(df2, names_from = var, values_from = value)
df2 %>% select(-row) %>% pivot_wide(spec = spec2)
```

